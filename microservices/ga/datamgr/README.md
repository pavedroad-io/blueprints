{{define "README.md"}}
# Working with your new {{.NameExported}} microservice

## roadctl
The roadctl command is modeled after kubectl.
Use "roadctl help" for a list of top level commands.
This may be different for a specific command or it's sub-commands.

### Top level help
    roadctl help

General help output:

```
roadctl allows you to work with the PavedRoad CNCF low-code environment and the associated CI

  Usage: roadctl [command] [TYPE] [NAME] [flags]

  TYPE specifies a resource type
  NAME is the name of a resource
  flags specify options

Usage:
  roadctl [command]

Available Commands:
  apply       Apply configuration to named resource
  completion  Generate completion scripts on stdout
  config      Manage roadctl global configuration options
  create      Create a new resource
  delete      Delete a resource
  deploy      Deploy a service
  describe    Describe provides detailed information about a resource
  doc         Generate documentation for your service
  edit        Edit the configuration for the specified resource
  events      View events
  explain     Return documentation about a resource
  get         Get an existing object
  help        Help about any command
  init        Initialize roadctl development environment
  logs        Return logs for a resource
  replace     Delete and recreate the named resource
  version     Print the current version

Flags:
      --config string      Config file (default is $HOME/.roadctl.yaml)
      --debug string       Debug level: info(default)|warn|error|critical (default "info")
      --format string      Output format: text(default)|json|yaml (default "text")
  -h, --help               help for roadctl
      --password string    HTTP basic auth password
      --blueprints string  Set the location of the directory holding roadctl blueprints
      --token string       OAUTH access token
      --user string        HTTP basic auth user name

Use "roadctl [command] --help" for more information about a command.
```

### Specific command
    roadctl get --help

Specific help output:

```
Return summary information about an existing resource

Usage:
  roadctl get [flags]

Flags:
  -h, --help   help for get

Global Flags:
      --config string      Config file (default is $HOME/.roadctl.yaml)
      --debug string       Debug level: info(default)|warn|error|critical (default "info")
      --format string      Output format: text(default)|json|yaml (default "text")
      --password string    HTTP basic auth password
      --blueprints string   Set the location of the directory holding roadctl blueprints
      --token string       OAUTH access token
      --user string        HTTP basic auth user name
```

## Generating your service
The roadctl CLI is used to create new services.
It has two fundamental concepts:

- blueprints: Contain logic need to generate a service
- definitions: Define your custom logic, integration's, and organizational information

A sample definitions is available to help you get started.

### Initialize blueprint repository
    roadctl init

### List available blueprints
    roadctl get blueprints

### Create a copy of the sample definition
    roadctl describe blueprints datamgr > myservice.yaml

Note: edit myservice.yaml to customize your create below.

### Get definitions of attributes in your myservice.txt
    roadctl explain blueprints datamgr > myservice.txt

### Create your microservice
    roadctl create blueprints datamgr -f myservice.yaml
### Build and test
Executing make will compile and test your service.
Optionally, you can do `make compile` followed by `make check`.

    make

## Directories

| Name | Contents |
| --------- | -------- |
| artifacts | Outputs from static code analysis and tests |
| assets | Generate assets such as images |
| builds | Executables for supported platforms, Mac/Linux x86/amd64 |
| dev | Generated helper scripts and sample data |
| dev/db | Generated SQL statements |
| docs | Generated documentation |
| logs | Logs generated by the microservice |
| manifests | Docker and docker-composes manifest |
| manifests/kubernetes | Kubernetes manifests for deploying this microservice |
| vendor | Vendor dependencies |

## SQL
To get an SQL prompt, use:

    /bin/sql.sh

## dev/testXXXXX.sh scripts
The following scripts work with your local docker images using
docker-compose or with the local microk8s cluster.  By default they
use the local docker image.  To use the microk8s cluster, use the -k
command line option/flag.

- dev/testAll.sh
- dev/testPost.sh
- dev/testPut.sh
- dev/testGet.sh
- dev/testGetList.sh

## make
Use **make help** to get a list of options:

    make help

Help output:

```
  Choose a command run in films:

  compile         Compile the binary.
  clean           Remove dep, vendor, binary(s), and executes go clean
  build           Build the binary for linux / mac x86 and amd
  deploy          Deploy image to repository and k8s cluster
  deploy-debug    Deploy image to the k8s cluster in headless debug mode
  deploy-down     Delete and cleanup deployment from the k8s cluster
  dev-mode        Start deployment in debug mode, watch for file changes and perform a live update
  tilt-up         Start service using Tilt UI
  tilt-down       Stop and cleanup a Tilt service
  install         Install packages or main
  check           Start services and execute static code analysis and tests
  show-coverage   Show go code coverage in browser
  show-test       Show sonarcloud test report
  show-devkit     Show documentation for Devkit
  fmt             Run gofmt on all code
  simplify        Run gofmt with simplify option
  k8s-start       Start local microk8s server and update configurations
  k8s-stop        Stop local k8s cluster and delete skaffold deployments
  k8s-status      Print the status of the local cluster up or down
  help            Print possible commands
  docker-build    Build docker images for use with docker-compose
  up              Start service using docker-compose
  down            Stop service using docker-compose
```

## Skaffold CI/CD
Skaffold is integrated into your project.  You can use the following commands:

### development mode
Monitors source code and when it changes builds and pushes a new image

```bash
skaffold dev -f manifests/skaffold.yaml
```
### run
Build and push the image when executed

```bash
skaffold run -f manifests/skaffold.yaml
```

### delete
Deletes all deployed resources

```bash
skaffold delete -f manifests/skaffold.yaml
```

### debug
Start skaffold container in k8s cluster in debug mode.
Use kubectl describe to return information for connecting
to the remote pod/image

#### Explicit

```bash
skaffold run -f manifests/skaffold.yaml -p dev-debug
```
#### Implicit

Automatically enter debug mode by declaring GODEBUG

```bash
export GODEBUG=true
skaffold run -f manifests/skaffold.yaml
```

## Linters
Three lint applications are integrated to assist in code reviews.

- Go lint checks for conformance with effective go programming recommendations and Go code review suggestions.
- Gosec tests your code against go recommended security practices
- Govet inspects code for constructs that might break.
- FOSSA license scanner
- SonarCloud scanner

The location of each lint's output is below along with links to the rules they enforce.

### golint
artifacts/lint.out
[Effective Go](https://golang.org/doc/effective_go.html)
[Go code review comments](https://github.com/golang/go/wiki/CodeReviewComments)

### gosec
artifacts/gosec.out
[Rules](https://securego.io/docs/rules/rule-intro.html)

### go vet
artifacts/govet.out
[Go vet rules](https://golang.org/cmd/vet/)

### SonarCloud and FOSSA
docs/service.html
Badges/Shields for both with links to details can be found in the generated
service.html in the docs directory.

# SonarCloud
SonarCloud provides free code analysis for open-source projects.
Note, Shield name is the text required in the definitions file.
By default, the following tools are included:

Shield name | Description
----------- | --------------------------------------------------
reliability_rating | Grade for code reliability, i. e. "A, B .... F"
quality gate | A score of release ability, passing or failing
bugs | Coding error that needs to be fixed
code_smells | SCA errors/warnings and comments with TODO
coverage | Test coverage percentage for new code
duplicate_line_density | Percent of repeating code lines
ncloc | Total number of lines of code
alert_status | Quality gate status passing or failing
sequrity_rating | A grade for your security status, i.e. "A,B...F"
vulnerabilities | Number of security threats in your code
sqale_rating | Maintainability of code grade, i. e. "A,B...F"
sqale_index | Estimate of time to address technical  debit


Support for SonarCloud is pre-integrated in the generated Makefile.

You need to set a valid sonarcloud token before executing make in
your .bashrc file:

export SONARCLOUD_TOKEN=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

## Getting a token
Go to https://sonarcloud.io.  Then login with your GitHub account.

Next, go to https://sonarcloud.io/account/security/.
In the Generate Tokens dialog, enter a name for your token
and click the "Generate" button.


## sonar-project.properties

Controls the executing of an analysis run.  Documentation is
available [here](https://docs.sonarqube.org/latest/analysis/analysis-parameters/).
The default configuration provides extended support for code coverage and go lint reporting.


# FOSSA
FOSSA provides free license scanning for open-source projects.   The [fossa-cli](https://github.com/fossas/fossa-cli/) documentation is covers basic usage.  Support for fossa is pre-integrated in the generated Makefile.  You need to set a valid fossa token before executing make in your .bashrc file:

export FOSSA_API_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXX

## Getting a token

Go to https://app.fossa.com.  Then login with your GitHub account.

Next, go to https://app.fossa.com/account/settings/integrations/api_tokens.
Use the "Add another Token" button to create your token.


## Run by hand using

```bash
FOSSA_API_KEY=$(FOSSA_API_KEY) fossa analyze
```

# GitHub token

Go to https://github.com and login.  Then go to, https://github.com/settings/tokens.
Use the "Generate new token" button to create your new token.

```bash
# add line to your .bashrc
export GH_ACCESS_TOKEN=####################
```
## Preflighting

The preflight.sh script ensures that the following required components
are installed:

- An initialized git repository exists
- The user.name and user.email are set in your git configuration
- A GitHub Personal Access Token is available in the GH_ACCESS_TOKEN env variable
- A .gitignore file with entries
- An initialized blueprints repository

It doesn't generate a git tag; pick your own. Once preflight.sh
successfully executes, a ".pr_preflight_check" is created.  Until this
file exists, Make will always attempt to run preflight.sh.

If you are running a version prior to v0.6.0alpha, you may run preflight.sh
by hand in the top level of your go microservice package with:

```bash
dev/preflight.sh
```

### Versioning information
The make file sets three versioning variables; VERSION, BUILD, and GIT_TAG.  These are passed go the go compiler and printed when the -v flag is passed on the command line.  Output is formatted as JSON:

    $ films -v
    {"Version": "1.0.0", "Build": "8755e7f", "GitTag": "v0.0alpha"}

VERSION := 1.0.0
----------------
The version variable is set based on the value you enter in your definitions file.

BUILD := $(shell git rev-parse --short HEAD)
--------------------------------------------
The build is set to the commit ID of your current git HEAD.

GIT_TAG := $(shell git describe)
--------------------------------
GIT_TAG set using the most recent tag if any.  You can add a tag with:

    git tag -a "mytag" -m "message about the tag."
Git push doesn't include tags.  To push tags to the origin use:

    git push origin --tag

{{/* vim: set filetype=gotexttmpl: */ -}}{{end}}
